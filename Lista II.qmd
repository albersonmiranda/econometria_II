---
title: "Lista II: Q1"
author: "Alberson Miranda"
date: "`r Sys.Date()`"
format:
  pdf:
    output-file: render/lista II.pdf
number-sections: true
mainfont: "Times New Roman"
monofont: "Consolas"
monofontoptions:
  - Scale=0.8
highlight-style: zenburn
header-includes: 
  - \renewcommand\thesubsection{\Alph{subsection}}
---

```{r configs}

# configurações
knitr::opts_chunk$set(
  fig.output = "70%"
)

# reproducibilidade
set.seed(1)

# pacotes
pacman::p_load(
    "ggplot2",
    "tsibble",
    "fable",
    "feasts",
    "fabletools",
    "urca"
)
```

# MODELAGEM BOX-JENKINS: SÉRIE I

O primeiro passo é a importação e visualização da série. Como não há informação sobre o período, usarei diário e tentarei identificar a partir de um padrão sazonal, se houver.

```{r data}

# importando dados
load("data/lista II.RData")
data = data.frame(
    value = conjunto1[, 1],
    index = seq(
        as.Date("2000-01-01"),
        by = 1,
        length.out = length(conjunto1[, 1])
    )
) |> tsibble(index = index)
```

A série é compacta, ou seja, de amplitude baixa, não requerindo transformação para redução de variância.

```{r plot}

# plot série
autoplot(data, .vars = value)
```

O segundo passo é testar se a série é estacionária no primeiro momento. Não há evidências de raiz unitária tanto nos testes quanto nos gráficos de autocorrelação. Para os testes ADF, iniciei com a especificação com tendência. Não sendo significativo o coeficiente `tt`, passei para a especificação com *drift*, sendo tanto o intercepto quanto `z.lag.1` significativos, adoto esta como a correta especificação e, assim como nos testes de Phillips-Perron e KPSS, não há inidcativo de raiz unitária.

```{r unit root}

# KPSS test
data |>
    features(value, unitroot_kpss)

# Phillips-Perron test
data |>
    features(value, unitroot_pp)

# Augmented-Dickey-Fuller test
data |>
    (\(x) ur.df(x$value, selectlags = "AIC", type = "trend", lags = 12))() |>
    summary()

data |>
    (\(x) ur.df(x$value, selectlags = "AIC", type = "drift", lags = 12))() |>
    summary()
```

A seguir, pode-se perceber decaimento na ACF e um pico na PACF, sugerindo um processo AR(1).

```{r autocorrelation}

# ACF
data |> ACF() |> autoplot()

# ACF
data |> PACF() |> autoplot()
```

Além do AR(1), também realizei uma *grid search*, que consiste na estimação de todas as combinações possíveis de modelos ARIMA dada uma restrição de coeficientes. Neste caso, como a análise do correlograma sugere um AR(1), optei por uma restrição parcimoniosa, com no máximo 3 coeficientes (AR ou MA) e sem testar modelos integrados, uma vez que foi constatada a estacionaridade. Dentre os modelos estimados, o de menor critério de informação foi o AR(1), no mesmo sentido da análise visual do correlograma.

```{r estimacao}

data_fit = data |>
  model(
    ar1 = ARIMA(
      value ~ 1 + pdq(1, 0, 0)
    ),
    search = ARIMA(
        value,
        stepwise = FALSE,
        trace = TRUE,
        order_constraint = p + q + P + Q <= 3 & (constant + d + D <= 1))
)
```

Antes de realizar predições, verificamos se os resíduos são ruído branco, o que indica que o modelo foi bem especificado.

```{r white noise}

# teste de Ljung-Box
data_fit |>
  dplyr::select(ar1) |>
  gg_tsresiduals()

augment(data_fit) |>
  dplyr::filter(.model == "ar1") |>
  features(.innov, ljung_box, lag = 12, dof = 2)
```

## MODELAGEM BOX-JENKINS: SÉRIE II

A série não parece estável. Recomendável transformação para estabilização da variância.

```{r box-cox transformation}

lambda = data |>
  features(value, features = guerrero) |>
  (\(x) x[["lambda_guerrero"]])()

data |>
    autoplot(box_cox(value, lambda))
```
