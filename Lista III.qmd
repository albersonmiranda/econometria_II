---
title: "Lista III"
author: "Alberson Miranda"
date: "`r Sys.Date()`"
format:
  pdf:
    output-file: render/lista II.pdf
number-sections: true
mainfont: "Times New Roman"
monofont: "Consolas"
monofontoptions:
  - Scale=0.8
highlight-style: zenburn
header-includes: 
  - \renewcommand\thesubsection{\Alph{subsection}}
---

```{r configs}

# configura√ß√µes
knitr::opts_chunk$set(
  out.width = "100%"
)

# reproducibilidade
set.seed(1)

# pacotes
pacman::p_load(
    "ggplot2"
)

# tema
tema = theme(text = element_text(size = 8))

# dados
load("data/lista_III.RData")
```

# Considere o banco de dados dadosSVAR. Este banco cont√©m 3 s√©ries temporais. Com base nessas informa√ß√µes fa√ßa o que se pede:

## Estime um VAR(p). Analise os res√≠duos e selecione a melhor ordem para o modelo. Escreva a equa√ß√£o do modelo indicando os elementos das matrizes.

```{r data wrangling}

# coercing to tsibble
data = data.frame(
    inflacao = inf,
    juros = juros,
    produto = y,
    index = tsibble::yearquarter(
        seq(
            as.Date("2000-01-01"),
            by = "quarter",
            length.out = length(y)
        )
    )
) |> tsibble::tsibble(index = index)

# plot s√©rie
data |>
tidyr::pivot_longer(
    -index,
    names_to = "s√©ries",
    values_to = "valor") |>
fabletools::autoplot() +
facet_grid(vars(s√©ries), scales = "free")
```

Para sele√ß√£o da ordem do VAR(p), usarei os crit√©rios de informa√ß√£o de Akaike corrigico (AICc) e o de Schwarz (BIC). Pelo princ√≠pio da parcim√¥nia, o modelo escolhido ser√° o de menor ordem dentre os que apresentarem ru√≠do branco. O AICc apontou para um VAR(4), enquanto o BIC para um VAR(5).

```{r ajuste}

# ajuste
fit = data |>
  fabletools::model(
    aicc = fable::VAR(vars(inflacao, juros, produto) ~ 1 + AR(p = 0:6), ic = "aicc"),
    bic = fable::VAR(vars(inflacao, juros, produto) ~ 1 + AR(p = 0:6), ic = "bic")
  )

# ordem
fit

# crit√©rios de informa√ß√£o
fabletools::glance(fit)
```

Analisando os res√≠duos, a ACF do VAR(4) ainda demostrou autocorrela√ß√£o significativa, enquanto a do VAR(5) se mostrou ru√≠do branco. Assim, selecionamos o VAR(5).

```{r diagnostico}

# ACF dos res√≠duos
fit |>
  fabletools::augment() |>
  feasts::ACF(.innov) |>
  autoplot()

# Portmanteau test
fabletools::augment(fit) |>
  subset(.model == "bic") |>
  fabletools::features(.innov, feasts::ljung_box, lag = 5)

# coeficientes
fit |>
    subset(select = bic) |>
    fabletools::report()

```

A equa√ß√£o do modelo √©:

$$
\begin{bmatrix}
    Y_{A, t} \\
    Y_{B, t} \\
    Y_{C, t} \\
\end{bmatrix}
=
\begin{bmatrix}
    \phi_{0A} \\
    \phi_{0B} \\
    \phi_{0C} \\
\end{bmatrix}
+
\begin{bmatrix}
    \phi_{11} & \phi_{12} & \phi_{13} \\
    \phi_{21} & \phi_{22} & \phi_{23} \\
    \phi_{31} & \phi_{32} & \phi_{33} \\
\end{bmatrix}
\begin{bmatrix}
    Y_{A, t-1} \\
    Y_{B, t-1} \\
    Y_{C, t-1} \\
\end{bmatrix}
+
\begin{bmatrix}
    \phi_{14} & \phi_{15} & \phi_{16} \\
    \phi_{24} & \phi_{25} & \phi_{26} \\
    \phi_{34} & \phi_{35} & \phi_{36} \\
\end{bmatrix}
\begin{bmatrix}
    Y_{A, t-2} \\
    Y_{B, t-2} \\
    Y_{C, t-2} \\
\end{bmatrix}
+
\hdots
+
\begin{bmatrix}
    \epsilon_{A, t} \\
    \epsilon_{B, t} \\
    \epsilon_{C, t} \\
\end{bmatrix}
$$

$$
\begin{split}
    \begin{bmatrix}
        Y_{i, t} \\
        Y_{j, t} \\
        Y_{p, t} \\
    \end{bmatrix}
    = \\
    &\begin{bmatrix}
        0.6477 \\
        0.0764 \\
        -0.0047 \\
    \end{bmatrix}
    + \\
    &\begin{bmatrix}
        1.4346 & -0.4282 & 6.2583 \\
        0.1373 & 1.4102 & -1.3161 \\
        0.0053 & -0.0014 & 0.5377 \\
    \end{bmatrix}
    \begin{bmatrix}
        Y_{i, t-1} \\
        Y_{j, t-1} \\
        Y_{p, t-1} \\
    \end{bmatrix}
    + \\
    &\begin{bmatrix}
        -0.7060 & 0.4701 & 6.9992 \\
        -0.1466 & -0.5880 & -1.3960 \\
        -0.0066 & 0.0053 & -0.1374 \\
    \end{bmatrix}
    \begin{bmatrix}
        Y_{i, t-2} \\
        Y_{j, t-2} \\
        Y_{p, t-2} \\
    \end{bmatrix}
    + \\
    &\vdots
    + \\
    &\begin{bmatrix}
        0.5813 & 0.0644 & -0.0011 \\
        0.0644 & 0.0656 & -0.0003 \\
        -0.0011 & -0.0003 & 0.0001 \\
    \end{bmatrix}
\end{split}
$$

## Fa√ßa o teste de causalidade de Granger para todas as vari√°veis.

1. Juros x Infla√ß√£o

A 5% de signific√¢ncia, n√£o h√° evid√™ncias para rejei√ß√£o da hip√≥tese nula de que a infla√ß√£o n√£o Granger-causa os juros (e vice-versa).
```{r causalidade 1}

# juros x infla√ß√£o
lmtest::grangertest(juros ~ inflacao, order = 5, data = data)
lmtest::grangertest(inflacao ~ juros, order = 5, data = data)
```

2. Infla√ß√£o x Produto

A 5% de signific√¢ncia, n√£o h√° evid√™ncias para rejei√ß√£o da hip√≥tese nula de que o produto n√£o Granger-causa a infla√ß√£o (e vice-versa).
```{r causalidade 2}

# produto x infla√ß√£o
lmtest::grangertest(inflacao ~ produto, order = 5, data = data)
lmtest::grangertest(produto ~ inflacao, order = 5, data = data)
```

3. Produto x Juros

A 5% de signific√¢ncia, n√£o h√° evid√™ncias para rejei√ß√£o da hip√≥tese nula de que o produto n√£o Granger-causa os juros (e vice-versa).
```{r causalidade 3}

# produto x juros
lmtest::grangertest(juros ~ produto, order = 5, data = data)
lmtest::grangertest(produto ~ juros, order = 5, data = data)
```

## Estime um SVAR considerando o modelo da letra A e as seguintes restri√ß√µes para as rela√ß√µes contempor√¢neas: (i) y afeta inf e juros; (ii) inf afeta apenas juros por√©m n√£o impacta y; (iii) juros n√£o impacta y ou inf.

```{r data wrangling para svar}

# wrangling
data = cbind(inf, juros, y)

# restri√ß√µes
mat_A = diag(3)
mat_A[3, 1] = NA
mat_A[1, 2] = NA
mat_A[3, 2] = NA

# ajuste
fit = vars::VAR(data, p = 5)
fit_s = vars::SVAR(fit, Amat = mat_A, estmethod = "direct")

# coeficientes
summary(fit_s)
```

## Escreva, considerando o modelo estimado na letra c, a equa√ß√£o do SVAR indicando os elementos de todas as matrizes.

$$
\begin{split}
    \begin{bmatrix}
        1 & -0.982810 & 0 \\
        0 & 1 & 0 \\
        0.001883 & 0.001882 & 1 \\
    \end{bmatrix}
    \begin{bmatrix}
        Y_{i, t} \\
        Y_{j, t} \\
        Y_{p, t} \\
    \end{bmatrix}
\end{split}
$$

E os demais coeficientes? N√£o entendi. √â pra inverter a matriz e multiplicar pelos coeficientes do modelo irrestrito? N√£o est√° claro como o resultado da fun√ß√£o se encaixa com a teoria estudada.

## Obtenha e analise a fun√ß√£o impulso resposta e a decomposi√ß√£o da vari√¢ncia do erro de previs√£o. Voc√™ deve utilizar o VAR(p) ou o SVAR para essa an√°lise? Justifique sua resposta.

Deve-se usar o VAR estrutural para que os par√¢metros estruturais sejam identific√°veis. Do contr√°rio, o problema da endogeneidade tornaria imposs√≠vel atribuir a resposta a uma vari√°vel.

```{r funcao impulso-resposta}

par(mai = c(0,0,0,0))
# fun√ß√£o impulso-resposta: produto
plot(
    vars::irf(
        fit_s,
        impulse = "y",
        response = c("inf", "juros"),
        n.ahead = 10,
        ortho = FALSE,
        cumulative = FALSE
    )
)

# fun√ß√£o impulso-resposta: infla√ß√£o
plot(
    vars::irf(
        fit_s,
        impulse = "inf",
        response = c("y", "juros"),
        n.ahead = 10,
        ortho = FALSE,
        cumulative = FALSE
    )
)

# fun√ß√£o impulso-resposta: juros
plot(
    vars::irf(
        fit_s,
        impulse = "juros",
        response = c("y", "inf"),
        n.ahead = 10,
        ortho = FALSE,
        cumulative = FALSE
    )
)

# decomposi√ß√£o da vari√¢ncia
plot(
    vars::fevd(fit_s, n.ahead = 10)
)
```

# O arquivo quest√£o_2 cont√©m dados mensais sobre os √≠ndices de pre√ßos do consumidor no Jap√£o, Canad√°, Su√≠√ßa e EUA. Al√©m disso, conta com as taxas de c√¢mbio bilaterais com o Estados Unidos. As vari√°veis s√£o nomeadas, por exemplo, como JAPANCPI = √≠ndice de pre√ßos do Jap√£o e JAPANEX = taxa de c√¢mbio Jap√£o/EUA. Para essa quest√£o considere os dados at√© 12/2012

## Obtenha o logaritmo das s√©ries. Avalie se possuem raiz unit√°ria.

```{r}

# carregando func√ß√µes
library(dplyr, include.only = c("mutate", "across"))
library(tidyselect, include.only = "where")
library(urca)

# importando dados
data = readxl::read_excel("data/dados.xlsx")

# convertendo data
data = subset(data, ENTRY <= as.Date("2012-12-01")) |>
    mutate(ENTRY = tsibble::yearmonth(ENTRY)) |>
    mutate(across(where(is.character), as.numeric))

# coercing to tsibble
data = tsibble::tsibble(data, index = ENTRY)

# s√©ries em logs
data_log = data |>
    mutate(across(where(is.numeric), log))
```

```{r}
# plot s√©rie
data |>
tidyr::pivot_longer(
    -ENTRY,
    names_to = "s√©ries",
    values_to = "valor") |>
fabletools::autoplot() +
facet_grid(vars(s√©ries), scales = "free") +
labs(
    x = "",
    title = "S√âRIES EM N√çVEL"
) + tema

# plot s√©rie em log
data_log |>
    tidyr::pivot_longer(
        -ENTRY,
        names_to = "s√©ries",
        values_to = "valor") |>
    fabletools::autoplot() +
    facet_grid(vars(s√©ries), scales = "free") +
labs(
    x = "",
    title = "S√âRIES EM LOG"
) + tema
```

A seguir, os testes de ra√≠z unit√°ria.

1. JAPANEX: o modelo com tend√™ncia se mostrou bem especificado e $\hat{\tau} \nless \tau$, de forma que n√£o h√° evid√™ncias para rejeitar a hip√≥tese nula de ra√≠z unit√°ria.
2. JAPANCPI: a especifica√ß√£o com tend√™ncia foi n√£o significativa para a vari√°vel de tend√™ncia determin√≠stica. Passando para a especifica√ß√£o com *drift*, o modelo √© bem especificado. $\hat{\tau} < \tau$ a 1% de signific√¢ncia, ent√£o pode-se rejeitar a hip√≥tese nula e a s√©rie √© estacion√°ria.
3. USCPI: a especifica√ß√£o com tend√™ncia foi n√£o significativa para a vari√°vel de tend√™ncia determin√≠stica. Passando para a especifica√ß√£o com *drift*, o modelo √© bem especificado. $\hat{\tau} < \tau$ a 5% de signific√¢ncia, ent√£o pode-se rejeitar a hip√≥tese nula e a s√©rie √© estacion√°ria.

```{r raiz unitaria}

# Augmented-Dickey-Fuller test JAPANEX
data_log |>
    (\(x) ur.df(x$JAPANEX, selectlags = "AIC", type = "trend", lags = 12))() |>
    summary()

# Augmented-Dickey-Fuller test JAPANCPI
data_log |>
    (\(x) ur.df(x$JAPANCPI, selectlags = "AIC", type = "trend", lags = 12))() |>
    summary()

data_log |>
    (\(x) ur.df(x$JAPANCPI, selectlags = "AIC", type = "drift", lags = 12))() |>
    summary()

# Augmented-Dickey-Fuller test USCPI
data_log |>
    (\(x) ur.df(x$USCPI, selectlags = "AIC", type = "trend", lags = 12))() |>
    summary()

data_log |>
    (\(x) ur.df(x$USCPI, selectlags = "AIC", type = "drift", lags = 12))() |>
    summary()
```

## Estime a rela√ß√£o de longo prazo entre log(japanex) em fun√ß√£o de log(japancpi) e log(uscpi). Com base na metodologia de Engle-Granger, teste para cointegra√ß√£o.

N√£o podem ser cointegradas pois $log(JAPANCPI)$ e $log(USCPI)$ s√£o estacion√°rias. Se n√£o o fossem, o procedimento seria realizar a regress√£o e verificar se os res√≠duos s√£o estacion√°rios.

Neste caso, a especifica√ß√£o correta para o teste ADF seria sem tend√™ncia e sem drift. Se acordo com o resultado, rejeitaria a hip√≥tese nula e os res√≠duos seriam estacion√°rios. Entretanto, a ACF √© de uma s√©rie com ra√≠z unit√°ria, vide decaimento lento. Verificar.

```{r}
# modelo
modelo = lm(log(JAPANEX) ~ log(JAPANCPI) + log(USCPI), data = data)
summary(modelo)

# plots dos res√≠duos
plot.ts(modelo$residuals)
acf(modelo$residuals)

# teste de ra√≠z unit√°ria
summary(ur.df(modelo$residuals, selectlags = "AIC", type = "trend", lags = 12))
summary(ur.df(modelo$residuals, selectlags = "AIC", type = "drift", lags = 12))
summary(ur.df(modelo$residuals, selectlags = "AIC", type = "none", lags = 12))
```

## Construa, caso necess√°rio, o modelo de corre√ß√£o de erros para ùõ•log(japanex).

Como o sinal do vetor de erro √© positivo e n√£o significante, n√£o h√° cointegra√ß√£o.

```{r}
vecm = lm(diff(log(JAPANEX))[-1] ~ modelo$residuals[-1:-2] + log(JAPANCPI[-1:-2]) + log(USCPI[-1:-2]) + diff(log(JAPANEX))[-(length(data$JAPANEX) - 1)], data = data)

summary(vecm)
```
